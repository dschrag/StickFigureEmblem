<html>
<head>
    <title>Stick FIguRE EMBLEM Game</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel=stylesheet href="css/base.css" />
</head>
<body>
    <script type="text/javascript" src="js/three.min.js"></script>
    <script type="text/javascript" src="js/Three.js"></script>
    <script type="text/javascript" src="js/Detector.js"></script>
    <script type="text/javascript" src="js/Stats.js"></script>
    <script type="text/javascript" src="js/OrbitControls.js"></script>
    <script type="text/javascript" src="js/THREEx.KeyboardState.js"></script>
    <script type="text/javascript" src="js/THREEx.FullScreen.js"></script>
    <script type="text/javascript" src="js/THREEx.WindowResize.js"></script>
    <script type="text/javascript" src="js/DAT.GUI.min.js"></script>
   
    <script type="text/javascript" src="js/Unit.js"></script>
    <script type="text/javascript" src="js/Player.js"></script>


    <script src="js/jquery-1.9.1.js"></script>
    <script src="js/jquery-ui.js"></script>
    <link rel=stylesheet href="css/jquery-ui.css" />
    <link rel=stylesheet href="css/info.css" />
    <script src="js/info.js"></script>


    <div id="ThreeJS" style="position: absolute; left:0px; top:0px"></div>

    <script>

        /*
            Stick Figure Emblem Game client
            Purdue CS252 Final Project. Fall 2015
            Author:
                Daniel Miller (dmiller4991@gmail.com)
            
            This is the HTML that houses all of the back end calculations
            and does all of the THREE.js manipulation of OpenGL. 
            Models made in Blender, open source 3D modeling.
            
        */
        // main
        var container, scene, camera, renderer, mesh, controls;
        var models = new Array();
        var modelIndex = 0;
        var currentModel;

        var posx = 0;
        var posy = 0;
        var posz = 0;

        var clock = new THREE.Clock();
        var keyboard = new THREEx.KeyboardState();
        var projector, mouse = {x: 0, y: 0};

        var targetlist = [];
        var unitArray = [];
        var unitIndex = 0;

        var Player1, Player2, currentPlayer;

        // control boolean flags
        var assignBool = false;
        var setBoard = false;
        var timeout = false;

        //basic movement variables. 
        var animOffset = 0;   // starting frame of animation
        var walking = false;
        var duration = 1000; //milliseconds to complete animation
        var keyframes = 20;   // total number of animation frames
        var interpolation = duration / keyframes; // milliseconds per frame
        var lastKeyframe = 0;    // previous keyframe
        var currentKeyframe = 0;
        var movementKeys = ["up", "down", "left", "right"]; // four cardinal directions 
        var forbidKeys = [false, false, false, false] // prevent from keeping moving until you do something different.
        
        // GUI stuff
        var turnGUI; // GUI denoting player turn. 
        var unitGUI; // GUI showing when currentModel isn't undefined and it's the proper player.

       

        init();

        animate();

        // initializing stuff
        function init()
        {
            // creating a new scene
            scene = new THREE.Scene();
            THREE.ImageUtils.crossOrigin = '';
            // setting up camera
            var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
            var VIEW_ANGLE = 60, ASPECT = 1.5 *( SCREEN_WIDTH / SCREEN_HEIGHT ), NEAR = 0.1, FAR = 20000;
            camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
            scene.add(camera);
            camera.position.set(0, 650, -675);
            camera.lookAt(scene.position);


            // set up renderer
            if (Detector.webgl)
            {
                renderer = new THREE.WebGLRenderer({ antialias: true });
            }
            else
            {
                renderer = new THREE.CanvasRenderer();
            }
            renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
            container = document.getElementById('ThreeJS');
            container.appendChild(renderer.domElement);

            // setup Events
            THREEx.WindowResize(renderer, camera);


            // setup controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);


            // set up light
            var light = new THREE.PointLight(0xffffff);
            light.position.set(0, 250, 0);
            scene.add(light);

            //floor
            var floorTexture = new THREE.ImageUtils.loadTexture('images/grasschecker.jpg');
            floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
            floorTexture.repeat.set(10, 10);
            var floorMaterial = new THREE.MeshBasicMaterial( {map: floorTexture, side: THREE.DoubleSide} );
            var floorWireframe = new THREE.MeshBasicMaterial( {color: 0x00ee00, wireframe: true, transparant: true} );
	        var floorMaterials = [floorMaterial, floorWireframe];

	        var floorGeometry = new THREE.PlaneGeometry(1000, 1000, 10, 10);

	        var floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.position.y = -0.5;
            floor.rotation.x = Math.PI / 2;
            scene.add(floor);


            // setup skybox
            var image = "images/forest.jpg";
            var materialArray = [];
            for (var i = 0; i < 6; i++)
                materialArray.push(new THREE.MeshBasicMaterial({
                    map: THREE.ImageUtils.loadTexture(image),
                    side: THREE.BackSide
                }));
            var skyMaterial = new THREE.MeshFaceMaterial(materialArray);
            var skyGeometry = new THREE.CubeGeometry(10000, 10000, 10000);
            var skyBox = new THREE.Mesh(skyGeometry, skyMaterial);

            scene.add(skyBox);

            projector = new THREE.Projector();


            // loading in initial models.
            var jsonloader = new THREE.JSONLoader();
            for (i = 0; i < 2; i++)
            {
                jsonloader.load("models/stickfigurewarrior.json", addModelToScene);

                jsonloader.load("models/stickfiguremage.json", addModelToScene);

                jsonloader.load("models/stickfigureranger.json", addModelToScene);
            }

            document.addEventListener('mousedown', eventClicked, false);
        }

        // adding models
        function addModelToScene(geometry, materials) {
            var tempArray = new Array;
            var material = new THREE.MeshFaceMaterial(materials);
            models[modelIndex] = new THREE.Mesh(geometry, material);
            models[modelIndex].scale.set(10, 10, 10);
            // 25 is the magic number that sets the units in the proper positions.
            models[modelIndex].position.set(25, 0, 25);
            var unit = new Unit("warrior");
            unit.setModel(models[modelIndex]);
            unitArray.push(unit);
            unitIndex++;
            targetlist.push(models[modelIndex]);
            scene.add(models[modelIndex]);
            modelIndex++;

        }

        function eventClicked(event)
        {
            console.log("Clicked on something");

            // update "mouse"
            mouse.x = (event.clientX / innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / innerHeight) * 2 + 1;
            //finding interactions
            var vector = new THREE.Vector3(mouse.x, mouse.y, 1);
            projector.unprojectVector(vector, camera);
            var ray = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());

            var intersections = ray.intersectObjects(targetlist);

            if (intersections.length > 0 )
            {
                // part of the target list of units.
                console.log("Clicked a model");
                currentModel = intersections[0].object; // grabbing the actual object
                console.log("currentModel position x: " + currentModel.position.x);
                console.log("currentModel position z: " + currentModel.position.z);
                
                // spawn GUI here
                if(currentModel != undefined)
                {
                    var currentUnit = searchModel();

                    if (currentUnit != null)
                    {
                        console.log("unitGUI: " + unitGUI);
                        if (unitGUI != undefined)
                            unitGUI.destroy();
                        console.log("unitGUI2: " + unitGUI);
                        unitGUI = new dat.GUI();
                        if (currentUnit.pOwner == currentPlayer.playerNum)
                        {
                            var text = {
                                unitClass: currentUnit.unitClass,
                                health: currentUnit.health,
                                owner: currentUnit.pOwner,
                                move: function () { console.log("moving stuff"); move();},
                                attack: function () { console.log("attacking stuff"); attack();},
                            };
                            unitGUI.add(text, 'health').name("Health");
                            unitGUI.add(text, 'unitClass').name("Class");
                            unitGUI.add(text, 'owner').name("Owner");
                            unitGUI.add(text, 'move').name("Move");
                            unitGUI.add(text, 'attack').name("Attack");
                        }
                        else
                        {
                            var text = {
                                unitClass: currentUnit.unitClass,
                                health: currentUnit.health,
                                owner: currentUnit.pOwner
                            };
                            unitGUI.add(text, 'health').name("Health");
                            unitGUI.add(text, 'unitClass').name("Class");
                            unitGUI.add(text, 'owner').name("Owner");
                        }
                    }
                    else {
                        console.log("unit not found");
                    }
                }
            }
            else
            {
                console.log("clicked on something else");
                console.log("unitGUI: " + unitGUI);
                unitGUI.close();
                currentModel = undefined;
            }

        }

        // will do our rendering.
        function animate()
        {
            requestAnimationFrame(animate);
            render();
            update();
                
        }

        function render()
        {
            renderer.render(scene, camera);
        }

        function update()
        {
            // big function that is called to do all of the back end stuff.
            // Handles movement, game setup, and (eventually) turn play.
            var currentPosition; 
            if (unitArray.length >= 6 && !assignBool) {
                // assigning units to players. 
                log();
                assignUnits();
                console.log("Showing unit classes")
                for (i = 0; i < unitArray.length; i++)
                {
                    console.log("Unit class at " + i + " is " + unitArray[i].unitClass);
                    console.log("Unit owner at " + i + " is " + unitArray[i].pOwner);
                }
            }
            if (assignBool && !setBoard)
            {
                // setting up initial game state. 
                log();
                setGameBoard();
            }


            // keyboard events. 
            if (keyboard.pressed("down") && currentModel != undefined)
            {
                clearForbidKeys("down")
                currentPosition = currentModel.position; 
                if (!(currentModel.position.z <= -475))
                {
                    var check = checkForUnits("down", currentPosition);
                    if (!check || forbidKeys[0])
                        console.log("cannot stand on unit")
                    else 
                        currentModel.position.z -= 25;
                }
                else 
                    console.log("hit lower bound")
            }

            if (keyboard.pressed("up") && currentModel != undefined)
            {
                clearForbidKeys("up");
                currentPosition = currentModel.position;
                if (currentModel.position.z >= 475)
                    console.log("hit upper boundary.")
                else
                {
                    var check = checkForUnits("up", currentPosition);
                    if (!check || forbidKeys[1])
                    {
                        console.log("Cannot Stand on Unit")
                    }
                    else 
                        currentModel.position.z += 25;
                }
                    
            }

            if (keyboard.pressed("left") && currentModel != undefined)
            {
                clearForbidKeys("left");
                currentPosition = currentModel.position;
                if (currentModel.position.x >= 475)
                    console.log("hit left boundary");
                else
                {
                    var check = checkForUnits("left", currentPosition);
                    if (!check || forbidKeys[2])
                    {
                        console.log("Cannot stand on unit")
                    }
                    else 
                        currentModel.position.x += 25;
                }
            }

            if (keyboard.pressed("right") && currentModel != undefined) {
                clearForbidKeys("right")
                currentPosition = currentModel.position;
                if (currentModel.position.x <= -475)
                    console.log("hit right boundary");
                else
                {
                    var check = checkForUnits("right", currentPosition);
                    if (!check || forbidKeys[3])
                        console.log("Cannot stand on unit");
                    else 
                        currentModel.position.x -= 25;
                }    
            }

            controls.update();
            //stats.update();
        }

        function move() {

        }

        function attack() {

        }

        function log() {    
            console.log("targetList.length: " + targetlist.length);
            console.log("Unit array length logged: " + unitArray.length);
            console.log("Unit index logged: " + unitIndex);
        }

        function searchModel()
        {
            var searchkey = currentModel.position;
            for (i = 0; i < unitArray.length; i++)
            {
                if (searchkey == unitArray[i].unitModel.position)
                    return unitArray[i];

            }
            return null;
        }

        function assignUnits()
        {
            Player1 = new Player(1);
            Player2 = new Player(2);

            // spawn turn tracker GUI
            turnGUI = new dat.GUI();
            var text = {
                player: Player1.playerNum,
                endTurn: function () { newTurn();}
            }
            turnGUI.add(text, 'player').name('Current Player');
            turnGUI.add(text, 'endTurn').name('End Turn');

            // assigning units
            for (i = 0; i <= 2; i++) {
                console.log("current i: " + i);
                var tempUnit = unitArray[i];
                var tempUnit2 = unitArray[i + 3];
                console.log("tempUnit: " + tempUnit);
                console.log("tempUnit: " + tempUnit2);
                if (i % 3 == 0){
                    tempUnit.unitClass = "warrior";
                    tempUnit.unitClass = "warrior";
                }
                else if (i % 3 == 1){
                    tempUnit.unitClass = "mage";
                    tempUnit.health = 190;
                    tempUnit2.unitClass = "mage";
                    tempUnit2.health = 190;
                }
                else {
                    if (i % 3 == 2){
                        tempUnit.unitClass = "ranger";
                        tempUnit.health = 125;
                        tempUnit2.unitClass = "ranger";
                        tempUnit2.health = 125;
                    }
                }
                unitArray[i].pOwner = Player1.playerNum;
                unitArray[i+3].pOwner = Player2.playerNum;
                Player1.addUnits(unitArray[i]);
                Player2.addUnits(unitArray[i + 3]);
                console.log("done");
            }
            assignBool = true;
        }

        function setGameBoard()
        {

            Player1.unitArray[0].unitModel.position.set(-475, 0, -475);
            Player1.unitArray[1].unitModel.position.set(-375, 0, -475);
            Player1.unitArray[2].unitModel.position.set(-275, 0, -475);
            Player2.unitArray[0].unitModel.position.set(275, 0, 475);
            Player2.unitArray[1].unitModel.position.set(375, 0, 475);
            Player2.unitArray[2].unitModel.position.set(475, 0, 475);

            Player1.unitArray[0].setMoves();
            Player1.unitArray[1].setMoves();
            Player1.unitArray[2].setMoves();
            Player2.unitArray[0].setMoves();
            Player2.unitArray[1].setMoves();
            Player2.unitArray[2].setMoves();

            currentPlayer = Player1; 
            setBoard = true;
        }

        function newTurn()
        {
            if (currentPlayer == Player1)
                currentPlayer = Player2; 
            else 
                currentPlayer = Player1;

            turnGUI.destroy();
            turnGUI = new dat.GUI();
            unitGUI.destroy();
            unitGUI = new dat.GUI();
            
            var text = {
                player: currentPlayer.playerNum,
                endTurn: function () { newTurn(); }
            }
            turnGUI.add(text, 'player').name('Current Player');
            turnGUI.add(text, 'endTurn').name('End Turn')

        }
        
        function checkForUnits(direction, position)
        {
            for (i =0 ; i < unitArray.length; i++)
            {
                var unitModel = unitArray[i].unitModel;
                console.log("unit " + i + " x: " + unitModel.position.x);
                console.log("unit " + i + " z: " + unitModel.position.z);
                console.log("current unit x: " + currentModel.position.x);
                console.log("current unit z: " + currentModel.position.z);
                if (direction == "left")
                {
                    if ((currentModel.position.x + 25) == unitModel.position.x
                        && currentModel.position.z == unitModel.position.z)
                    {
                        console.log("Unit " + i + " on the left!!!")
                        currentModel.position.set(position.x-25, position.y, position.z)
                        forbidKeys[2] = true; 
                        return false; 
                    }
                }
                if (direction == "right")
                {
                    if ((currentModel.position.x - 25) == unitModel.position.x
                        && currentModel.position.z == unitModel.position.z) {
                        console.log("Unit " + i + " on the right!!!")
                        currentModel.position.set(position.x + 25, position.y, position.z)
                        forbidKeys[3] = true;
                        return false;
                    }
                }
                if (direction == "up")
                {
                    if (currentModel.position.x == unitModel.position.x
                        && (currentModel.position.z + 25)== unitModel.position.z) {
                        console.log("Unit " + i + " on the top!!!")
                        currentModel.position.set(position.x, position.y, position.z - 25)
                        forbidKeys[1] = true;
                        return false;
                    }
                }
                if (direction == "down")
                {
                    if (currentModel.position.x == unitModel.position.x
                        && (currentModel.position.z - 25) == unitModel.position.z) {
                        console.log("Unit " + i + " on the bottom!!!")
                        currentModel.position.set(position.x, position.y, position.z + 25)
                        forbidKeys[0] = true;
                        return false;
                    }
                }
            }
            return true;
        }
        function clearForbidKeys(direction)
        {
            for (i = 0; i < 4; i++)
            {
                if (movementKeys[i] == direction)
                    continue;
                else 
                    forbidKeys[i] = false;
            }
        }

    </script>
</body>
</html>
